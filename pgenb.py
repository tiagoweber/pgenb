#!/usr/bin/python3

"""
PGEN-B: PWL Voltage Source Generator from Bitstream
Version: 0.1.0

This program was created to help circuit designers have a quick and easy way to generate PWL voltage sources from bitstreams to use in SPICE simulators.

Copyright 2025 Tiago Oliveira Weber
License: MIT License
Repository: https://github.com/tiagoweber/pgenb
Website: www.tiagoweber.com.br
Contact: tiago.oliveira.weber@gmail.com
"""

import tkinter as tk
from tkinter import ttk
from tkinter import Menu
from tkinter import scrolledtext
from tkinter import messagebox
from tkinter import filedialog
from tkinter import font

from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import (FigureCanvasTkAgg, NavigationToolbar2Tk)
from datetime import date

import webbrowser  # for hyperlink

class tab:
    def __init__(self,name,parentframe,parent):
        self.name = name
        self.parentframe = parentframe
        self.tabframe = ttk.Frame(self.parentframe)
        self.parent = parent
        self.canvas = None

        self.time_list = []
        self.value_list = []
        self.vhigh = float(self.parent.vhigh_entry.get())
        self.vlow = float(self.parent.vlow_entry.get())

        self.is_populated = False # initial condition

        # initial values
        self.bitstream = "10101011001"
        self.comment = ""
        self.vsource_name = "in%d"%(self.parent.bitstream_counter)
        self.outnode_name = "out%d"%(self.parent.bitstream_counter)
        
        self.spice_string_about = ""        
        self.spice_string_header = ""
        self.spice_string_pwl = ""
        self.spice_string_bottom = ""
        self.spice_string_csv = ""
        
        #self.intabframe = tk.Frame(self.tabframe, bg="darkgray")
        #self.intabframe.pack(expand=True,fill="both", padx=1, pady=1)
        
        # tk.Label(parentframe, text="optionbar", fg="black").pack(padx=1, pady=1) 

        parentframe.pack(expand=False,fill="x", padx=1, pady=1)

    def destroy_figure(self):
        if self.canvas == None:
            pass
        else:
            self.canvas.get_tk_widget().destroy()
            #self.canvas = None
            
    def update_figure(self):
        # the figure that will contain the plot
        fig = Figure(figsize = (10, 4), dpi = 60)
        
        #y = [i**2 for i in range(101)]
        #self.value_list = value_list
        #self.time_list = time_list
        x = self.time_list
        y = self.value_list

        plot1 = fig
        #plot1 = fig.add_subplot(111)
        plot1 = fig.add_subplot()

        plot1.set_xlabel("Time")
        plot1.set_ylabel("Voltage")
        plot1.plot(x,y)

        self.fig = fig
        
        canvas = FigureCanvasTkAgg(fig, master = self.graphframe)  
        canvas.draw()
        self.canvas = canvas
        self.graphframe.pack(side=tk.TOP,expand=True,fill="both", padx=1, pady=1)
        self.canvas.get_tk_widget().pack(side=tk.TOP, fill="both", expand=True)

    def contain_only_1s_0s(self,bits):
        only_bits = True
        for bit in bits:
            if (bit != "1" and bit != "0"):
                only_bits = False
                break
            
        return only_bits

    def voltage_descr(self,bit):
        if bit == 0:
            return "vlow"
        else:
            return "vhigh"

    def voltage(self,bit):
        if bit == 0:
            return self.vlow
        else:
            return self.vhigh

    def generate_code(self):

        self.text_area.delete('1.0', tk.END) #delete all
        today = date.today()
        year = today.year
        month = today.month
        day = today.day
        # create string with code to generate
        
        spice_string_about ="* Generated by PGEN-B: PWL Generator from Bitstream %d-%d-%d\n"%(year,month,day)
        spice_string_header = ""

        spice_string_header+=".param clk_period = %g\n"%self.period
        spice_string_header+=".param tr = %g\n"%self.trise
        #spice_string+=".param tstep = %g\n"%self.tstep
        spice_string_header+=".param Vhigh = %g\n"%self.vhigh
        spice_string_header+=".param Vlow = %g\n"%self.vlow    
        
        # PWL part
        #spice_string+="V%s %s 0 PWL (\n"%(self.vsource_name, self.outnode_name)
        if self.comment != "":
            spice_string_comment = "* Comment: %s\n"%self.comment
        else:
            spice_string_comment = ""
        spice_string_pwl ="V%s %s 0 PWL ("%(self.vsource_name, self.outnode_name)
        spice_string_pwl_descr ="V%s %s 0 PWL ("%(self.vsource_name, self.outnode_name)
        spice_string_csv = ""
        # loop
        for i, item in enumerate (self.value_list):
            value = self.value_list[i]
            time = self.time_list[i]

            time_descr = self.time_list_descr[i]
            value_descr = self.value_list_descr[i]
            
            #spice_string+="+ %g %g\n"%(time,value)
            spice_string_pwl+=" %g %g "%(time,value)
            spice_string_pwl_descr+=" %s %s "%(time_descr, value_descr)
            #0 0 {2*tstep-tr/2} 0 {2*tstep+tr/2} {vhigh} {4*tstep-tr/2} {vhigh} {4*tstep+tr/2} 0 {5*tstep-tr/2} 0 {5*tstep+tr/2} {vhigh} {6*tstep-tr/2} {vhigh} {6*tstep+tr/2} 0 {7*tstep-tr/2} 0 {7*tstep+tr/2} {vhigh} {8*tstep-tr/2} {vhigh} {8*tstep+tr/2} 0 {9*tstep} 0 ) ; bitstream: 001101010
            
            spice_string_csv+="%g, %g\n"%(time,value)

        spice_string_pwl+=" )\n"


        
        spice_string_bottom = ".param simstep = {tr}\n"
        spice_string_bottom+= ".param simstime = %g\n"%self.time_list[-1]                                                               
        spice_string_bottom+= ".tran {simstep} {simtime}\n"
        spice_string_bottom+= ".control\n"
        spice_string_bottom+= "run\n"
        spice_string_bottom+= ".endc\n"
        spice_string_bottom+= ".end\n"

        self.spice_string_about = spice_string_about
        self.spice_string_header = spice_string_header
        self.spice_string_comment = spice_string_comment
        self.spice_string_pwl = spice_string_pwl
        self.spice_string_bottom = spice_string_bottom
        self.spice_string_csv = spice_string_csv
        
        # populate self.text_area
        #self.text_area
        if self.use_params:
            self.text_area.insert(tk.INSERT,spice_string_about+spice_string_header+spice_string_comment+spice_string_pwl+spice_string_bottom)
        else: 
            self.text_area.insert(tk.INSERT,spice_string_about+spice_string_comment+spice_string_pwl+spice_string_bottom)
        
    def generate_pwl(self,bit_list_int):#, period, trise,vhigh,vlow):
        
        init_time = 0
        init_value = self.voltage(0)

        time_list = [init_time]
        value_list = [init_value]
        time_list_descr = ["0"]
        value_list_descr = [self.voltage_descr(0)]
        
        #t_step = self.period/2  #it is from self 
        base_time = 0
        base_time_descr = "0"
        
        for i, bit in enumerate(bit_list_int):
            old_value = value_list[-1]
            old_time = time_list[-1]
            old_time_descr = time_list_descr[-1]
            old_value_descr = value_list_descr[-1]

            value = self.voltage(bit_list_int[i])
            value_descr = self.voltage_descr(bit_list_int[i])
            
            if i==0:                
                # end of transition
                value_list.append(value)
                time_list.append(base_time+self.trise/2)

                value_list_descr.append(value_descr)
                time_list_descr.append(base_time_descr+"+trise/2")
                
            else:
                base_time = old_time + self.tstep
                base_time_descr = "%d*tstep"%(i)  # HERE
                # begin of transition
                value_list.append(old_value)
                time_list.append(base_time-self.trise/2)

                value_list_descr.append(old_value_descr)
                time_list_descr.append( base_time_descr+"-trise/2")
                
                # end of transition
                value_list.append(value)
                time_list.append(base_time+self.trise/2)

                value_list_descr.append(value_descr)
                time_list_descr.append( base_time_descr+"+trise/2")

            base_time += self.tstep   #isnt it redundunt?


        # last value
        value_list.append(value)
        time_list.append(base_time)

        value_list_descr.append(value_descr)
        time_list_descr.append(base_time_descr)        

        self.value_list = value_list
        self.time_list = time_list

        self.value_list_descr = value_list_descr
        self.time_list_descr = time_list_descr

        #self.pwl_values = 

    def update_input_variables(self):

        self.vhigh = float(self.parent.vhigh_entry.get())
        self.vlow = float(self.parent.vlow_entry.get())
        self.bitstream = self.bitstream_entry.get()
        self.comment = self.comment_entry.get()
        self.period = float(self.parent.period_entry.get())
        self.trise = float(self.parent.trise_entry.get())
        self.vsource_name = self.vsource_name_entry.get()
        self.outnode_name = self.outnode_name_entry.get()
        #messagebox.showinfo("Tab","Use Half!")
        self.use_params = self.parent.use_params.get()
        self.use_half = self.parent.use_half.get()  # getting it from the parent object (which is automatically updated as it is a checkbutton)
        if self.use_half:         
            self.tstep = self.period/4            
            
        else:
            self.tstep = self.period/2

    def button_delete(self):
        # delete itself
        tab_id = self.parent.tabControl.select()
        # print("Tab id: %s"%tab_id)

        #before forgetting the tab_id, make sure to select the first one (or one that is not the "+" one)
        #self.parent.tabControl.tabs()[0]
        self.parent.tabControl.select(0)

        # forget (from tabcontrol)
        self.parent.tabControl.forget(tab_id)

        # delete from tab list
        self.parent.tabs.remove(self)
        

        

        
    def button_generate(self):

        try:            
            #messagebox.showinfo("Tab","A tab")
            self.update_input_variables()
            
            
            bit_list = list(self.bitstream)
            if (not( self.contain_only_1s_0s(bit_list))):
                messagebox.showerror("Error","Hey, you need to use only 1's and 0's")
            if self.period == "":
                messagebox.showerror("Error","Hey, you need to fill \"period\" or \"freq\" value")
            if self.trise == "":
                messagebox.showerror("Error","Hey, you need to fill \"rise time\" value")
            if self.vhigh == "":
                messagebox.showerror("Error","Hey, you need to fill \"vhigh\" value")
            if self.vlow == "":
                messagebox.showerror("Error","Hey, you need to fill \"vlow\" value")                                                
            else:
                bit_list_int = []
                for bit in bit_list:
                    bit_int = int(bit)
                    bit_list_int.append(bit_int)
                self.generate_pwl(bit_list_int)#, period, trise,vhigh,vlow)
                self.destroy_figure()
                self.update_figure()
                self.generate_code()

        except (ValueError, TypeError) as e:            
            messagebox.showerror("Error",f"An error occurred: {e}")
    
    def populate(self):
        #print("populating tab")
        self.is_populated = True
        
        tab_line1 = tk.Frame(self.tabframe)# bg="lightyellow")
        tk.Label(tab_line1, text="bitstream: ", fg="black").pack(side="left", padx=1, pady=1)
        #tk.Button(tab_line1, text= "Generate", command=self.button_generate).pack(side="right", padx=1, pady=1)
        tk.Button(tab_line1, text= "Remove bitstream", command=self.button_delete).pack(side="right", padx=1, pady=1)
        self.bitstream_entry = tk.Entry(tab_line1, width=50)
        self.bitstream_entry.insert(0, self.bitstream)
        self.bitstream_entry.pack(side="left",expand=True,fill="x")        
        tab_line1.pack(expand=True,fill="both")
        
        tab_line1_2 = tk.Frame(self.tabframe)# bg="lightyellow")
        tk.Label(tab_line1_2, text="comment: ", fg="black").pack(side="left", padx=1, pady=1)
        
        self.comment_entry = tk.Entry(tab_line1_2, width=50)
        self.comment_entry.insert(0, self.comment)
        self.comment_entry.pack(side="left",expand=True,fill="x")        

        tab_line1_2.pack(expand=True,fill="both")



        tab_line2 = tk.Frame(self.tabframe)#, bg="lightgreen")
        #tk.Label(tab_line2, text="Graph", fg="black").pack(side="top", expand=True, fill="x",padx=1, pady=1)

        vsource_name_label = tk.Label(tab_line2, text="V source name: ", fg="black").pack(side="left",padx=1, pady=1) 
        self.vsource_name_entry = tk.Entry(tab_line2, width=8)
        self.vsource_name_entry.insert(0, self.vsource_name)
        self.vsource_name_entry.pack(side="left")

        outnode_name_label = tk.Label(tab_line2, text="Output node name: ", fg="black").pack(side="left",padx=1, pady=1) 
        self.outnode_name_entry = tk.Entry(tab_line2, width=8)
        self.outnode_name_entry.insert(0, self.outnode_name)
        self.outnode_name_entry.pack(side="left")

        tab_line2.pack(expand=True,fill="both")

        
        tab_line3 = tk.Frame(self.tabframe)#, bg="lightgreen")
        tk.Label(tab_line3, text="Graph", fg="black").pack(side="top", expand=True, fill="x",padx=1, pady=1)
        tab_line3.pack(expand=True,fill="both")
        
    
        graphframe = tk.Frame(tab_line3)# bg="darkgray")
        self.graphframe = graphframe
        #self.update_figure()        
        #self.canvas.get_tk_widget().pack()

        tab_line4 = tk.Frame(self.tabframe)# bg="lightblue")
        tk.Label(tab_line4, text="Generated Code", fg="black").pack(side="top", expand=True, fill="x",padx=1, pady=1)

        text_area = scrolledtext.ScrolledText(tab_line4, 
                                      wrap = tk.WORD, 
                                      #width = 80, 
                                      height = 10, 
                                      font = ("Times New Roman",
                                              10))
        self.text_area = text_area
        text_area.pack(side="bottom",expand=True,fill="both")
        tab_line4.pack(expand=True,fill="both")
        
        
        
    def add(self):
        self.parentframe.add(self.tabframe, text=self.name)
        
class program:
    def __init__(self):
        
        root = tk.Tk()
        self.root = root
        root.title("PGEN-B: PWL Generator from Bitstream")
        root.config(bg="white")
        root.geometry("800x600")
        #tk.Label(root, text="root", fg="black").pack(padx=1, pady=1) #pad: represent the number of pixels surrounding the widget
        
        self.bitstream_counter = 0
        # Outerframe as parent
        outerframe = tk.Frame(root, width=800, height=600)#, bg="green")
        parentframe = outerframe
        #tk.Label(parentframe, text="outerframe", fg="black").pack(padx=1, pady=1) 
        parentframe.pack(expand=True,fill="both", padx=1, pady=1)

        # Menuframe as parent  # There is no need, as menu applies to the root
        #menuframe = tk.Frame(outerframe, bg="lightgray")
        #self.menuframe = menuframe
        #parentframe = menuframe
        #tk.Label(parentframe, text="menuframe", fg="black").pack(padx=1, pady=1) 
        #parentframe.pack(expand=False,fill="x", padx=1, pady=1)

        self.tabs = []

        
        # Optionbar as parent
        optionbar = tk.Frame(outerframe)#, bg="darkgray")
        self.optionbar = optionbar
        parentframe = optionbar
        optionbar_line1 = tk.Frame(optionbar)#, bg="white")
        optionbar_line1.pack(expand=True,fill="x", padx=1, pady=1)
        optionbar_line2 = tk.Frame(optionbar)#, bg="pink")
        optionbar_line2.pack(expand=True,fill="x", padx=1, pady=1)
        self.optionbar_line1 = optionbar_line1
        self.optionbar_line2 = optionbar_line2
        # tk.Label(parentframe, text="optionbar", fg="black").pack(padx=1, pady=1) 
        parentframe.pack(expand=True,fill="x", padx=10, pady=20)        

        # Tabframe
        tabControl = ttk.Notebook(outerframe)
        self.tabControl = tabControl


        self.tabControl.bind("<<NotebookTabChanged>>", self.handleTabChange)
        

        # ***************************** end of the overall frame creation

        # populating menuframe
        self.populate_menuframe()
        
        # populating options
        self.populate_options()
        
        # Creation of the initial tab
        self.newfile()
        
        # populating tabs
        self.populate_tabs()
        
        # main loop        
        root.mainloop()

    def handleTabChange(self,event):
            if self.tabControl.select() == self.tabControl.tabs()[-1]:
                index = len(self.tabControl.tabs())-1
                #frame = tk.Frame(self.tabControl)
                #self.tabControl.insert(index, frame, text="<untitled>")
                #self.tabControl.select(index)
                tabnew = tab("bitstream %d"%self.bitstream_counter,self.tabControl,self)
                self.tabs.append(tabnew)
                self.bitstream_counter+=1
                
                self.populate_tabs()
            else:
                selected_tab_id = self.tabControl.select()
                self.tab_index = self.tabControl.index(selected_tab_id)
                #self.tabControl.select(self.tab_index)  # it is done by default


    def populate_options(self):
        # parent = self.optionbar
        #freq_label = tk.Label(self.optionbar_line1, text="Frequency (Hz): ", fg="black").pack(side="left",padx=1, pady=1) 
        #freq_entry = tk.Entry(self.optionbar_line1, width=8).pack(side="left")

        period_label = tk.Label(self.optionbar_line1, text="Period (s): ", fg="black").pack(side="left",padx=1, pady=1) 
        self.period_entry = tk.Entry(self.optionbar_line1, width=8)
        self.period_entry.insert(0, "1e-6")  
        self.period_entry.pack(side="left")

        trise_label = tk.Label(self.optionbar_line1, text="Rise and Fall Time (s): ", fg="black").pack(side="left",padx=1, pady=1) 
        self.trise_entry = tk.Entry(self.optionbar_line1, width=8)
        self.trise_entry.insert(0, "1e-8")
        self.trise_entry.pack(side="left")

        vhigh_label = tk.Label(self.optionbar_line1, text="Vhigh (V): ", fg="black").pack(side="left",padx=1, pady=1) 
        self.vhigh_entry = tk.Entry(self.optionbar_line1, width=8)
        self.vhigh_entry.insert(0, "1.2")
        self.vhigh_entry.pack(side="left")
        
        vlow_label = tk.Label(self.optionbar_line1, text="Vlow (V): ", fg="black").pack(side="left",padx=1, pady=1) 
        self.vlow_entry = tk.Entry(self.optionbar_line1, width=8)
        self.vlow_entry.insert(0, "0")
        self.vlow_entry.pack(side="left")
        
        self.use_half = tk.IntVar()
        self.use_half_checkbtn = tk.Checkbutton(self.optionbar_line2, text='Use half period for each bit',variable=self.use_half, onvalue=1, offvalue=0, command=None)
        self.use_half_checkbtn.pack(side="left",padx=1,pady=1)#expand=True,fill="both")
        
        

        self.use_params = tk.IntVar()
        self.use_params_checkbtn = tk.Checkbutton(self.optionbar_line2, text='Use params',variable=self.use_params, onvalue=1, offvalue=0, command=None)
        self.use_params_checkbtn.pack(side="left", padx=1, pady=1) #expand=True,fill="both")

        tk.Button(self.optionbar_line2, text= "Generate", command=self.button_generate_all).pack(side="left", expand=True, fill="both", padx=10)#, pady=1)
        
        # vsource_name_label = tk.Label(self.optionbar_line2, text="V source name: ", fg="black").pack(side="left",padx=1, pady=1) 
        # self.vsource_name_entry = tk.Entry(self.optionbar_line2, width=8)
        # self.vsource_name_entry.insert(0, "insignal")
        # self.vsource_name_entry.pack(side="left")

        # outnode_name_label = tk.Label(self.optionbar_line2, text="Output node name: ", fg="black").pack(side="left",padx=1, pady=1) 
        # self.outnode_name_entry = tk.Entry(self.optionbar_line2, width=8)
        # self.outnode_name_entry.insert(0, "out")
        # self.outnode_name_entry.pack(side="left")
        
        
    def about(self):
        # messagebox.showinfo("About",
        #                     "PGEN: PWL Voltage Source Generator from Bitstream \n" \
        #                     "Author: Tiago Oliveira Weber\n" \
        #                     "\n" \
        #                     "Created on November 2025\n" \
        #                     "\n" \
        #                     "e-mail: tiago.oliveira.weber@gmail.com\n"\
        #                     "site: www.tiagoweber.com.br\n" \
        #                     )
        about_window = tk.Toplevel(self.root)
        about_window.title("About PGEN-B")
        about_window.config(bg="lightgray")
        about_window.geometry("600x400")
        
        outerframe = tk.Frame(about_window, width=400, height=400)#, bg="green")


        parentframe = outerframe


        ascii_art =  r"""
---------------------------------------------
######   #####  ####### #     #       ######  
#     # #     # #       ##    #       #     # 
#     # #       #       # #   #       #     # 
######  #  #### #####   #  #  # ##### ######  
#       #     # #       #   # #       #     # 
#       #     # #       #    ##       #     # 
#        #####  ####### #     #       ######  
---------------------------------------------
        """
        mono_font = font.Font(family="Courier", size=12)
        tk.Label(parentframe, text=ascii_art, font= mono_font, fg="black",justify='left').pack(side="top",expand=True,fill="both",padx=0, pady=0)


        
        tk.Label(parentframe, text="PGEN-B: PWL Generator from Bitstream", fg="black").pack(padx=1, pady=1)
        tk.Label(parentframe, text="This program was created to help circuit designers have a quick and easy way to generate PWL voltage sources from bitstreams to use in SPICE simulators.", fg="black", wraplength=300).pack(padx=10, pady=10) 
        tk.Label(parentframe, text="Created on November 2025", fg="black").pack(padx=1, pady=1)
        tk.Label(parentframe, text="Author: Tiago Oliveira Weber", fg="black").pack(padx=1, pady=1) 
        
        parentframe.pack(expand=True,fill="both", padx=1, pady=1)
        
    def clean_tabs(self,keep_self_tabs=False):

        for tab_id in self.tabControl.tabs():            
            self.tabControl.forget(tab_id)

        if not(keep_self_tabs):
            self.tabs = []

    def loadfile(self):
        
        file_path = filedialog.askopenfilename(defaultextension=".txt", filetypes=[("Text files", "*.txt"), ("Circuit files", "*.cir"), ("All files", "*.*")])
        if file_path:
            try:
                with open(file_path, 'r') as fr:
                    is_config_file = False
                    line_num = 0
                    tab_num = 0
                    got_it_all = False

                    tabname = ""
                    vhigh = 1.2
                    vlow = 0
                    bitstream = "000"
                    comment = ""
                    period = 1e-6
                    trise = 1e-9
                    vsource_name = "in"
                    outnode_name = "out"
                    
                    for line in fr:                        
                        line = line.strip()
                        if (line_num == 0) and (line == "Config file"):
                            is_config_file = True

                        elif (line_num == 0):
                            messagebox.showerror("Error",("File is not a config file"))
                            break

                        parts = line.split("=")
                        for i in range(0,len(parts)):
                            parts[i] = parts[i].strip()
                                                              
                        if "tabname" in parts[0]:
                            tabname = parts[1]
                            
                        if "vhigh" in parts[0]:
                            vhigh = float(parts[1])

                        if "vlow" in parts[0]:
                            vlow = float(parts[1])

                        if "bitstream" in parts[0]:                            
                            bitstream = parts[1]

                        if "comment" in parts[0]:                            
                            comment = parts[1]

                        if "period" in parts[0]:
                            period = float(parts[1])

                        if "trise" in parts[0]:
                            trise = float(parts[1])

                        if "vsourcename" in parts[0]:
                            vsourcename = parts[1]

                        if "outnode_name" in parts[0]:
                            outnode_name = parts[1]
                            got_it_all = True
                    
                        # will get here if is a config file                        
                        if (got_it_all):                            
                            newtab = tab(tabname,self.tabControl,self)
                            newtab.vhigh = vhigh
                            newtab.vlow = vlow
                            newtab.bitstream = bitstream
                            newtab.comment = comment
                            newtab.period = period
                            newtab.trise = trise
                            newtab.vsource_name = vsource_name
                            newtab.outnode_name = outnode_name                            
                            self.tabs.append(newtab)
                            tab_num += 1
                            got_it_all= False
                        
                        line_num+=1

                    self.clean_tabs(keep_self_tabs=True)
                    self.populate_tabs()
                    self.tabControl.select(0)
                    
                #status_label.config(text=f"File saved: {file_path}")
            except Exception as e:
                #status_label.config(text=f"Error saving file: {str(e)}")
                messagebox.showerror("Error", ("Error opening file: %s"%str(e)))

    def button_generate_all(self):
        for tab in self.tabs:
            tab.button_generate()
            
    def savefile(self):
        self.button_generate_all()
        
        file_path = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Text files", "*.txt"), ("Circuit files", "*.cir"), ("All files", "*.*")])
        if file_path:
            try:
                with open(file_path, 'w') as fw:

                    fw.write("Config file\n")
                    fw.write("use_half = %d\n"%self.use_half.get())
                    fw.write("use_params = %d\n"%self.use_params.get())
                    # save all overall things
                    for tab in self.tabs:
                        fw.write("tabname = %s\n"%tab.name)
                        fw.write("vhigh = %g\n"%tab.vhigh)
                        fw.write("vlow = %g\n"%tab.vlow)
                        fw.write("bitstream = %s\n"%tab.bitstream)
                        fw.write("comment = %s\n"%tab.comment)
                        fw.write("period = %g\n"%tab.period)
                        fw.write("trise = %g\n"%tab.trise)
                        fw.write("vsource_name = %s\n"%tab.vsource_name)                
                        fw.write("outnode_name = %s\n"%tab.outnode_name)                        
                    
                #status_label.config(text=f"File saved: {file_path}")
            except Exception as e:
                #status_label.config(text=f"Error saving file: {str(e)}")
                messagebox.showerror("Error", ("Error saving file: %s"%str(e)))

        
    def newfile(self):
        self.clean_tabs()

        self.bitstream_counter = 0
        
        #tab1 = tab("bitstream 0",self.tabControl,self)
        tab1 = tab("bitstream %d"%self.bitstream_counter,self.tabControl,self)
        self.tabs.append(tab1)
        self.bitstream_counter+=1

        self.populate_tabs()

        
    def populate_menuframe(self):
        
        # parent = self.menuframe
        menubar = Menu(self.root)

        # filemenu
        filemenu = Menu(menubar, tearoff = 0)
        menubar.add_cascade(label ='File', menu = filemenu)
        filemenu.add_command(label ='New Config File', command = self.newfile)
        filemenu.add_command(label ='Open Config File...', command = self.loadfile)
        filemenu.add_command(label ='Save Config File', command = self.savefile)
        filemenu.add_command(label ='About', command = self.about)
        filemenu.add_separator()
        filemenu.add_command(label ='Exit', command = self.root.destroy)

        # output
        outputmenu = Menu(menubar, tearoff = 0)
        menubar.add_cascade(label ='Output', menu = outputmenu)

        outputmenu.add_command(label ='Copy current generated voltage source to clipboard', command = self.export_current_tab_source_to_clipboard)
        outputmenu.add_command(label ='Export current generated code to file', command = self.export_current_tab_code_to_file)
        outputmenu.add_command(label ='Export current data to CSV', command = self.export_current_tab_csv_to_file)
        outputmenu.add_separator()        
        outputmenu.add_command(label ='Copy ALL generated voltage source to clipboard', command = self.export_all_tab_source_to_clipboard)
        outputmenu.add_command(label ='Export ALL generated code to file', command = self.export_all_tab_code_to_file)
        outputmenu.add_command(label ='Export ALL data to CSV', command = self.export_all_tab_csv_to_file)

        
        # viewmenu
        # viewmenu = Menu(menubar, tearoff = 0)
        # menubar.add_cascade(label ='Mode', menu = viewmenu)
        # viewmenu.add_command(label ='Edit Mode', command = None)
        # viewmenu.add_command(label ='View Mode', command = None)

        
        self.root.config(menu = menubar)

    def export_all_tab_csv_to_file(self):
        file_path = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Text files", "*.txt"), ("Circuit files", "*.cir"), ("All files", "*.*")])
        if file_path:
            try:
                with open(file_path, 'w') as fw:

                    # print header
                    fw.write("Time")
                    for selected_tab in self.tabs:
                        #print("tab name: %s "%selected_tab.name)
                        fw.write(", %s"%selected_tab.name)
                        
                    fw.write("\n")
                    
                    time_lists = []
                    value_lists = []
                    longest_time_list_idx = 0
                    longest_time_list_len = 0
                    
                    for t, selected_tab in enumerate(self.tabs):
                        time_lists.append(selected_tab.time_list)
                        value_lists.append(selected_tab.value_list)
                        if len(time_lists[t]) > longest_time_list_len:
                            longest_time_list_idx = t
                            longest_time_list_len = len(time_lists[t])


                    for i,time in enumerate(time_lists[longest_time_list_idx]):
                        fw.write("%g"%time)

                        for value_list in value_lists:
                            last_value_index = len(value_list)   
                            if i < last_value_index:   # check if value_list is long enough
                                fw.write(", %g"%value_list[i])
                            else:
                                fw.write(", %g"%value_list[-1])

                        fw.write("\n")
                        
                    
                    
                #status_label.config(text=f"File saved: {file_path}")
            except Exception as e:
                #status_label.config(text=f"Error saving file: {str(e)}")
                messagebox.showerror("Error", ("Error saving file: %s"%str(e)))

        
    def export_all_tab_code_to_file(self):
        file_path = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Text files", "*.txt"), ("Circuit files", "*.cir"), ("All files", "*.*")])
        if file_path:
            try:
                with open(file_path, 'w') as fw:
                    for t, selected_tab in enumerate(self.tabs):
                        if t == 0:
                            fw.write(selected_tab.spice_string_about)
                            if (self.use_params == 1):
                                fw.write(selected_tab.spice_string_header)
                            
                        fw.write(selected_tab.spice_string_comment)
                        if (self.use_params):
                            fw.write(selected_tab.spice_string_pwl_descr)
                        else:
                            fw.write(selected_tab.spice_string_pwl)
                            
                        if t == len(self.tabs)-1:
                            fw.write(selected_tab.spice_string_bottom)
                    
                #status_label.config(text=f"File saved: {file_path}")
            except Exception as e:
                #status_label.config(text=f"Error saving file: {str(e)}")
                messagebox.showerror("Error", ("Error saving file: %s"%str(e)))

    def export_current_tab_csv_to_file(self):

        file_path = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Text files", "*.txt"), ("Circuit files", "*.cir"), ("All files", "*.*")])
        if file_path:
            try:
                with open(file_path, 'w') as fw:
                    selected_tab = self.tabs[self.tab_index]                                             
                    fw.write(selected_tab.spice_string_csv)
                    
                #status_label.config(text=f"File saved: {file_path}")
            except Exception as e:
                #status_label.config(text=f"Error saving file: {str(e)}")
                messagebox.showerror("Error", ("Error saving file: %s"%str(e)))


    def export_all_tab_source_to_clipboard(self):

        self.root.clipboard_clear()   # part of Tk
        for t, selected_tab in enumerate(self.tabs):
            
            if t == 0:
                #self.root.clipboard_append(selected_tab.spice_string_about)
                #self.root.clipboard_append(selected_tab.spice_string_header)
                pass

            self.root.clipboard_append(selected_tab.spice_string_pwl)

                
    def export_current_tab_source_to_clipboard(self):
        selected_tab = self.tabs[self.tab_index]
        string_to_clipboard = selected_tab.spice_string_header+selected_tab.spice_string_pwl

        self.root.clipboard_clear()   # part of Tk
        #self.root.clipboard_append(selected_tab.spice_string_header)
        self.root.clipboard_append(selected_tab.spice_string_pwl)


        
        
        
    def export_current_tab_code_to_file(self):

        file_path = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Text files", "*.txt"), ("Circuit files", "*.cir"), ("All files", "*.*")])
        if file_path:
            try:
                with open(file_path, 'w') as fw:
                    selected_tab = self.tabs[self.tab_index]
                    if self.use_params == 1:
                        fw.write(selected_tab.spice_string_header)
                    if self.use_params == 1:
                        fw.write(selected_tab.spice_string_pwl_descr)
                    else:
                        fw.write(selected_tab.spice_string_pwl)
                        
                    fw.write(selected_tab.spice_string_bottom)
                #status_label.config(text=f"File saved: {file_path}")
            except Exception as e:
                #status_label.config(text=f"Error saving file: {str(e)}")
                messagebox.showerror("Error", ("Error saving file: %s"%str(e)))
                

    def populate_tabs(self):

        # remove the "+" tab if it exists. It will always exist if is not the first run of this function
        num_tabs = self.tabControl.index(tk.END)
        if num_tabs > 0:
            self.tabControl.forget(num_tabs-1) #remove "+" tab, as it will be added in the last place

        # populate the others
        for tab in self.tabs:
            if (tab.is_populated):
                pass
            else:
                tab.populate()
                tab.add()
                tab.button_generate()


        # select the last one
        self.tab_index = len(self.tabControl.tabs())-1
        # the "+" tab
        self.tabControl.select(self.tab_index)
        self.tabplus = ttk.Frame(self.tabControl)
        self.tabControl.add(self.tabplus, text="+")


        self.tabControl.pack(expand = True, fill="both")        


            
program()
